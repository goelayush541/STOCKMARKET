{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport { api } from '../services/api';\nexport const useSignals = (filters = {}) => {\n  _s();\n  const [signals, setSignals] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null);\n\n  // Memoize the mock data generator to prevent recreation on every render\n  const generateMockSignals = useCallback((limit = 10) => {\n    const symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META'];\n    const signalTypes = ['BUY', 'SELL', 'NEUTRAL'];\n    const sources = ['technical', 'news', 'market', 'pattern'];\n    return Array.from({\n      length: limit\n    }, (_, i) => ({\n      _id: `mock_signal_${Date.now()}_${i}`,\n      symbol: symbols[Math.floor(Math.random() * symbols.length)],\n      signalType: signalTypes[Math.floor(Math.random() * signalTypes.length)],\n      strength: Math.random() * 0.5 + 0.5,\n      confidence: Math.random() * 0.3 + 0.7,\n      source: sources[Math.floor(Math.random() * sources.length)],\n      generatedAt: new Date(),\n      explanation: 'Mock data - server connection issue',\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\n      isMock: true // Flag to identify mock data\n    }));\n  }, []);\n\n  // Memoize the fetch function to prevent unnecessary recreations\n  const fetchSignals = useCallback(async (filters, abortSignal) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await api.getSignals(filters);\n\n      // Handle different response formats\n      let signalsData = [];\n      if (Array.isArray(data)) {\n        signalsData = data;\n      } else if (data && Array.isArray(data.signals)) {\n        signalsData = data.signals;\n      } else if (data && data.pagination && Array.isArray(data.pagination.signals)) {\n        signalsData = data.pagination.signals;\n      }\n      setSignals(signalsData);\n    } catch (err) {\n      if (err.name === 'AbortError') {\n        console.log('Signal fetch request was aborted');\n        return;\n      }\n      console.error('Error fetching signals:', err);\n      setError(err.message);\n\n      // Fallback to mock data for specific error types\n      if (err.message.includes('Network error') || err.message.includes('Failed to fetch') || err.message.includes('Cannot connect to server')) {\n        const mockSignals = generateMockSignals(filters.limit || 10);\n        setSignals(mockSignals);\n        setError('Using mock data (server unavailable)');\n      } else {\n        setSignals([]);\n      }\n    } finally {\n      if (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted)) {\n        setLoading(false);\n      }\n    }\n  }, [generateMockSignals]);\n  useEffect(() => {\n    // Cancel previous request if it exists\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n    const abortSignal = abortControllerRef.current.signal;\n    fetchSignals(filters, abortSignal);\n\n    // Cleanup function to abort request if component unmounts or filters change\n    return () => {\n      if (abortControllerRef.current && !abortSignal.aborted) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [filters, fetchSignals]); // Include fetchSignals in dependencies\n\n  const refresh = useCallback(async () => {\n    // Cancel any ongoing request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n    const abortSignal = abortControllerRef.current.signal;\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await api.getSignals(filters);\n\n      // Handle different response formats\n      let signalsData = [];\n      if (Array.isArray(data)) {\n        signalsData = data;\n      } else if (data && Array.isArray(data.signals)) {\n        signalsData = data.signals;\n      }\n      if (!abortSignal.aborted) {\n        setSignals(signalsData);\n      }\n    } catch (err) {\n      if (err.name === 'AbortError') {\n        console.log('Refresh request was aborted');\n        return;\n      }\n      console.error('Error refreshing signals:', err);\n      if (!abortSignal.aborted) {\n        setError(err.message);\n\n        // Fallback to mock data\n        if (err.message.includes('Network error') || err.message.includes('Failed to fetch')) {\n          const mockSignals = generateMockSignals(filters.limit || 10);\n          setSignals(mockSignals);\n          setError('Using mock data (server unavailable)');\n        }\n      }\n    } finally {\n      if (!abortSignal.aborted) {\n        setLoading(false);\n      }\n    }\n  }, [filters, generateMockSignals]);\n\n  // Function to manually add a signal (useful for testing)\n  const addSignal = useCallback(signalData => {\n    const newSignal = {\n      _id: `manual_${Date.now()}`,\n      symbol: signalData.symbol,\n      signalType: signalData.signalType || 'NEUTRAL',\n      strength: signalData.strength || 0.5,\n      confidence: signalData.confidence || 0.7,\n      source: signalData.source || 'manual',\n      generatedAt: new Date(),\n      explanation: signalData.explanation || 'Manually added signal',\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\n      isManual: true\n    };\n    setSignals(prev => [newSignal, ...prev]);\n  }, []);\n\n  // Function to remove a signal by ID\n  const removeSignal = useCallback(signalId => {\n    setSignals(prev => prev.filter(signal => signal._id !== signalId));\n  }, []);\n\n  // Function to clear all signals\n  const clearSignals = useCallback(() => {\n    setSignals([]);\n  }, []);\n\n  // Function to filter signals by type\n  const filterByType = useCallback(signalType => {\n    return signals.filter(signal => signal.signalType === signalType);\n  }, [signals]);\n\n  // Function to filter signals by strength threshold\n  const filterByStrength = useCallback((minStrength = 0.7) => {\n    return signals.filter(signal => signal.strength >= minStrength);\n  }, [signals]);\n\n  // Function to get statistics\n  const getStats = useCallback(() => {\n    const total = signals.length;\n    const buySignals = signals.filter(s => s.signalType === 'BUY').length;\n    const sellSignals = signals.filter(s => s.signalType === 'SELL').length;\n    const neutralSignals = signals.filter(s => s.signalType === 'NEUTRAL').length;\n    const averageStrength = signals.reduce((sum, s) => sum + s.strength, 0) / total || 0;\n    const averageConfidence = signals.reduce((sum, s) => sum + s.confidence, 0) / total || 0;\n    return {\n      total,\n      buySignals,\n      sellSignals,\n      neutralSignals,\n      averageStrength: parseFloat(averageStrength.toFixed(2)),\n      averageConfidence: parseFloat(averageConfidence.toFixed(2)),\n      strongSignals: signals.filter(s => s.strength > 0.7).length\n    };\n  }, [signals]);\n  return {\n    signals,\n    loading,\n    error,\n    refresh,\n    addSignal,\n    removeSignal,\n    clearSignals,\n    filterByType,\n    filterByStrength,\n    getStats\n  };\n};\n_s(useSignals, \"W4o1zZEdguq5vXsrkf8sknriAoQ=\");\nexport default useSignals;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","api","useSignals","filters","_s","signals","setSignals","loading","setLoading","error","setError","abortControllerRef","generateMockSignals","limit","symbols","signalTypes","sources","Array","from","length","_","i","_id","Date","now","symbol","Math","floor","random","signalType","strength","confidence","source","generatedAt","explanation","expiration","isMock","fetchSignals","abortSignal","data","getSignals","signalsData","isArray","pagination","err","name","console","log","message","includes","mockSignals","aborted","current","abort","AbortController","signal","refresh","addSignal","signalData","newSignal","isManual","prev","removeSignal","signalId","filter","clearSignals","filterByType","filterByStrength","minStrength","getStats","total","buySignals","s","sellSignals","neutralSignals","averageStrength","reduce","sum","averageConfidence","parseFloat","toFixed","strongSignals"],"sources":["C:/Users/Ayush Goel/OneDrive/Desktop/DEPLOYED/STOCKMARKET/frontend/src/hooks/useSignals.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\r\nimport { api } from '../services/api';\r\n\r\nexport const useSignals = (filters = {}) => {\r\n  const [signals, setSignals] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const abortControllerRef = useRef(null);\r\n\r\n  // Memoize the mock data generator to prevent recreation on every render\r\n  const generateMockSignals = useCallback((limit = 10) => {\r\n    const symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META'];\r\n    const signalTypes = ['BUY', 'SELL', 'NEUTRAL'];\r\n    const sources = ['technical', 'news', 'market', 'pattern'];\r\n    \r\n    return Array.from({ length: limit }, (_, i) => ({\r\n      _id: `mock_signal_${Date.now()}_${i}`,\r\n      symbol: symbols[Math.floor(Math.random() * symbols.length)],\r\n      signalType: signalTypes[Math.floor(Math.random() * signalTypes.length)],\r\n      strength: Math.random() * 0.5 + 0.5,\r\n      confidence: Math.random() * 0.3 + 0.7,\r\n      source: sources[Math.floor(Math.random() * sources.length)],\r\n      generatedAt: new Date(),\r\n      explanation: 'Mock data - server connection issue',\r\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\r\n      isMock: true // Flag to identify mock data\r\n    }));\r\n  }, []);\r\n\r\n  // Memoize the fetch function to prevent unnecessary recreations\r\n  const fetchSignals = useCallback(async (filters, abortSignal) => {\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n      \r\n      const data = await api.getSignals(filters);\r\n      \r\n      // Handle different response formats\r\n      let signalsData = [];\r\n      if (Array.isArray(data)) {\r\n        signalsData = data;\r\n      } else if (data && Array.isArray(data.signals)) {\r\n        signalsData = data.signals;\r\n      } else if (data && data.pagination && Array.isArray(data.pagination.signals)) {\r\n        signalsData = data.pagination.signals;\r\n      }\r\n      \r\n      setSignals(signalsData);\r\n    } catch (err) {\r\n      if (err.name === 'AbortError') {\r\n        console.log('Signal fetch request was aborted');\r\n        return;\r\n      }\r\n      \r\n      console.error('Error fetching signals:', err);\r\n      setError(err.message);\r\n      \r\n      // Fallback to mock data for specific error types\r\n      if (err.message.includes('Network error') || \r\n          err.message.includes('Failed to fetch') || \r\n          err.message.includes('Cannot connect to server')) {\r\n        const mockSignals = generateMockSignals(filters.limit || 10);\r\n        setSignals(mockSignals);\r\n        setError('Using mock data (server unavailable)');\r\n      } else {\r\n        setSignals([]);\r\n      }\r\n    } finally {\r\n      if (!abortSignal?.aborted) {\r\n        setLoading(false);\r\n      }\r\n    }\r\n  }, [generateMockSignals]);\r\n\r\n  useEffect(() => {\r\n    // Cancel previous request if it exists\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n    }\r\n    \r\n    abortControllerRef.current = new AbortController();\r\n    const abortSignal = abortControllerRef.current.signal;\r\n\r\n    fetchSignals(filters, abortSignal);\r\n\r\n    // Cleanup function to abort request if component unmounts or filters change\r\n    return () => {\r\n      if (abortControllerRef.current && !abortSignal.aborted) {\r\n        abortControllerRef.current.abort();\r\n      }\r\n    };\r\n  }, [filters, fetchSignals]); // Include fetchSignals in dependencies\r\n\r\n  const refresh = useCallback(async () => {\r\n    // Cancel any ongoing request\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n    }\r\n    \r\n    abortControllerRef.current = new AbortController();\r\n    const abortSignal = abortControllerRef.current.signal;\r\n\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n      \r\n      const data = await api.getSignals(filters);\r\n      \r\n      // Handle different response formats\r\n      let signalsData = [];\r\n      if (Array.isArray(data)) {\r\n        signalsData = data;\r\n      } else if (data && Array.isArray(data.signals)) {\r\n        signalsData = data.signals;\r\n      }\r\n      \r\n      if (!abortSignal.aborted) {\r\n        setSignals(signalsData);\r\n      }\r\n    } catch (err) {\r\n      if (err.name === 'AbortError') {\r\n        console.log('Refresh request was aborted');\r\n        return;\r\n      }\r\n      \r\n      console.error('Error refreshing signals:', err);\r\n      if (!abortSignal.aborted) {\r\n        setError(err.message);\r\n        \r\n        // Fallback to mock data\r\n        if (err.message.includes('Network error') || \r\n            err.message.includes('Failed to fetch')) {\r\n          const mockSignals = generateMockSignals(filters.limit || 10);\r\n          setSignals(mockSignals);\r\n          setError('Using mock data (server unavailable)');\r\n        }\r\n      }\r\n    } finally {\r\n      if (!abortSignal.aborted) {\r\n        setLoading(false);\r\n      }\r\n    }\r\n  }, [filters, generateMockSignals]);\r\n\r\n  // Function to manually add a signal (useful for testing)\r\n  const addSignal = useCallback((signalData) => {\r\n    const newSignal = {\r\n      _id: `manual_${Date.now()}`,\r\n      symbol: signalData.symbol,\r\n      signalType: signalData.signalType || 'NEUTRAL',\r\n      strength: signalData.strength || 0.5,\r\n      confidence: signalData.confidence || 0.7,\r\n      source: signalData.source || 'manual',\r\n      generatedAt: new Date(),\r\n      explanation: signalData.explanation || 'Manually added signal',\r\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\r\n      isManual: true\r\n    };\r\n    \r\n    setSignals(prev => [newSignal, ...prev]);\r\n  }, []);\r\n\r\n  // Function to remove a signal by ID\r\n  const removeSignal = useCallback((signalId) => {\r\n    setSignals(prev => prev.filter(signal => signal._id !== signalId));\r\n  }, []);\r\n\r\n  // Function to clear all signals\r\n  const clearSignals = useCallback(() => {\r\n    setSignals([]);\r\n  }, []);\r\n\r\n  // Function to filter signals by type\r\n  const filterByType = useCallback((signalType) => {\r\n    return signals.filter(signal => signal.signalType === signalType);\r\n  }, [signals]);\r\n\r\n  // Function to filter signals by strength threshold\r\n  const filterByStrength = useCallback((minStrength = 0.7) => {\r\n    return signals.filter(signal => signal.strength >= minStrength);\r\n  }, [signals]);\r\n\r\n  // Function to get statistics\r\n  const getStats = useCallback(() => {\r\n    const total = signals.length;\r\n    const buySignals = signals.filter(s => s.signalType === 'BUY').length;\r\n    const sellSignals = signals.filter(s => s.signalType === 'SELL').length;\r\n    const neutralSignals = signals.filter(s => s.signalType === 'NEUTRAL').length;\r\n    const averageStrength = signals.reduce((sum, s) => sum + s.strength, 0) / total || 0;\r\n    const averageConfidence = signals.reduce((sum, s) => sum + s.confidence, 0) / total || 0;\r\n\r\n    return {\r\n      total,\r\n      buySignals,\r\n      sellSignals,\r\n      neutralSignals,\r\n      averageStrength: parseFloat(averageStrength.toFixed(2)),\r\n      averageConfidence: parseFloat(averageConfidence.toFixed(2)),\r\n      strongSignals: signals.filter(s => s.strength > 0.7).length\r\n    };\r\n  }, [signals]);\r\n\r\n  return { \r\n    signals, \r\n    loading, \r\n    error, \r\n    refresh,\r\n    addSignal,\r\n    removeSignal,\r\n    clearSignals,\r\n    filterByType,\r\n    filterByStrength,\r\n    getStats\r\n  };\r\n};\r\n\r\nexport default useSignals;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}