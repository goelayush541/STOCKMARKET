{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport { api } from '../services/api';\nexport const useSignals = (filters = {}) => {\n  _s();\n  const [signals, setSignals] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null);\n\n  // Memoize the mock data generator to prevent recreation on every render\n  const generateMockSignals = useCallback((limit = 10) => {\n    const symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META'];\n    const signalTypes = ['BUY', 'SELL', 'NEUTRAL'];\n    const sources = ['technical', 'news', 'market', 'pattern'];\n    return Array.from({\n      length: limit\n    }, (_, i) => ({\n      _id: `mock_signal_${Date.now()}_${i}`,\n      symbol: symbols[Math.floor(Math.random() * symbols.length)],\n      signalType: signalTypes[Math.floor(Math.random() * signalTypes.length)],\n      strength: Math.random() * 0.5 + 0.5,\n      confidence: Math.random() * 0.3 + 0.7,\n      source: sources[Math.floor(Math.random() * sources.length)],\n      generatedAt: new Date(),\n      explanation: 'Mock data - server connection issue',\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\n      isMock: true // Flag to identify mock data\n    }));\n  }, []);\n\n  // Memoize the fetch function to prevent unnecessary recreations\n  const fetchSignals = useCallback(async (currentFilters, abortSignal) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await api.getSignals(currentFilters);\n\n      // Handle different response formats\n      let signalsData = [];\n      if (Array.isArray(data)) {\n        signalsData = data;\n      } else if (data && Array.isArray(data.signals)) {\n        signalsData = data.signals;\n      } else if (data && data.pagination && Array.isArray(data.pagination.signals)) {\n        signalsData = data.pagination.signals;\n      }\n      if (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted)) {\n        setSignals(signalsData);\n      }\n    } catch (err) {\n      if (err.name === 'AbortError') {\n        console.log('Signal fetch request was aborted');\n        return;\n      }\n      console.error('Error fetching signals:', err);\n      if (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted)) {\n        setError(err.message);\n\n        // Fallback to mock data for specific error types\n        if (err.message.includes('Network error') || err.message.includes('Failed to fetch') || err.message.includes('Cannot connect to server')) {\n          const mockSignals = generateMockSignals(currentFilters.limit || 10);\n          setSignals(mockSignals);\n          setError('Using mock data (server unavailable)');\n        } else {\n          setSignals([]);\n        }\n      }\n    } finally {\n      if (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted)) {\n        setLoading(false);\n      }\n    }\n  }, [generateMockSignals]);\n  useEffect(() => {\n    // Cancel previous request if it exists\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n    const abortSignal = abortControllerRef.current.signal;\n    fetchSignals(filters, abortSignal);\n\n    // Cleanup function to abort request if component unmounts or filters change\n    return () => {\n      if (abortControllerRef.current && !abortSignal.aborted) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [filters, fetchSignals]);\n  const refresh = useCallback(async () => {\n    // Cancel any ongoing request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n    const abortSignal = abortControllerRef.current.signal;\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await api.getSignals(filters);\n\n      // Handle different response formats\n      let signalsData = [];\n      if (Array.isArray(data)) {\n        signalsData = data;\n      } else if (data && Array.isArray(data.signals)) {\n        signalsData = data.signals;\n      }\n      if (!abortSignal.aborted) {\n        setSignals(signalsData);\n      }\n    } catch (err) {\n      if (err.name === 'AbortError') {\n        console.log('Refresh request was aborted');\n        return;\n      }\n      console.error('Error refreshing signals:', err);\n      if (!abortSignal.aborted) {\n        setError(err.message);\n\n        // Fallback to mock data\n        if (err.message.includes('Network error') || err.message.includes('Failed to fetch')) {\n          const mockSignals = generateMockSignals(filters.limit || 10);\n          setSignals(mockSignals);\n          setError('Using mock data (server unavailable)');\n        }\n      }\n    } finally {\n      if (!abortSignal.aborted) {\n        setLoading(false);\n      }\n    }\n  }, [filters, generateMockSignals]);\n\n  // Function to manually add a signal (useful for testing)\n  const addSignal = useCallback(signalData => {\n    const newSignal = {\n      _id: `manual_${Date.now()}`,\n      symbol: signalData.symbol,\n      signalType: signalData.signalType || 'NEUTRAL',\n      strength: signalData.strength || 0.5,\n      confidence: signalData.confidence || 0.7,\n      source: signalData.source || 'manual',\n      generatedAt: new Date(),\n      explanation: signalData.explanation || 'Manually added signal',\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\n      isManual: true\n    };\n    setSignals(prev => [newSignal, ...prev]);\n  }, []);\n\n  // Function to remove a signal by ID\n  const removeSignal = useCallback(signalId => {\n    setSignals(prev => prev.filter(signal => signal._id !== signalId));\n  }, []);\n\n  // Function to clear all signals\n  const clearSignals = useCallback(() => {\n    setSignals([]);\n  }, []);\n\n  // Function to filter signals by type\n  const filterByType = useCallback(signalType => {\n    return signals.filter(signal => signal.signalType === signalType);\n  }, [signals]);\n\n  // Function to filter signals by strength threshold\n  const filterByStrength = useCallback((minStrength = 0.7) => {\n    return signals.filter(signal => signal.strength >= minStrength);\n  }, [signals]);\n\n  // Function to filter signals by symbol\n  const filterBySymbol = useCallback(symbol => {\n    return signals.filter(signal => signal.symbol === symbol.toUpperCase());\n  }, [signals]);\n\n  // Function to get active signals (not expired)\n  const getActiveSignals = useCallback(() => {\n    const now = new Date();\n    return signals.filter(signal => !signal.expiration || new Date(signal.expiration) > now);\n  }, [signals]);\n\n  // Function to get expired signals\n  const getExpiredSignals = useCallback(() => {\n    const now = new Date();\n    return signals.filter(signal => signal.expiration && new Date(signal.expiration) <= now);\n  }, [signals]);\n\n  // Function to get statistics\n  const getStats = useCallback(() => {\n    const total = signals.length;\n    const buySignals = signals.filter(s => s.signalType === 'BUY').length;\n    const sellSignals = signals.filter(s => s.signalType === 'SELL').length;\n    const neutralSignals = signals.filter(s => s.signalType === 'NEUTRAL').length;\n    const averageStrength = signals.reduce((sum, s) => sum + s.strength, 0) / total || 0;\n    const averageConfidence = signals.reduce((sum, s) => sum + s.confidence, 0) / total || 0;\n    const strongSignals = signals.filter(s => s.strength > 0.7).length;\n    const activeSignals = getActiveSignals().length;\n    const expiredSignals = getExpiredSignals().length;\n    return {\n      total,\n      buySignals,\n      sellSignals,\n      neutralSignals,\n      averageStrength: parseFloat(averageStrength.toFixed(2)),\n      averageConfidence: parseFloat(averageConfidence.toFixed(2)),\n      strongSignals,\n      activeSignals,\n      expiredSignals,\n      buyPercentage: total > 0 ? parseFloat((buySignals / total * 100).toFixed(1)) : 0,\n      sellPercentage: total > 0 ? parseFloat((sellSignals / total * 100).toFixed(1)) : 0\n    };\n  }, [signals, getActiveSignals, getExpiredSignals]);\n\n  // Function to update a signal\n  const updateSignal = useCallback((signalId, updates) => {\n    setSignals(prev => prev.map(signal => signal._id === signalId ? {\n      ...signal,\n      ...updates,\n      updatedAt: new Date()\n    } : signal));\n  }, []);\n\n  // Function to mark signal as read/unread\n  const markSignalAsRead = useCallback(signalId => {\n    updateSignal(signalId, {\n      isRead: true\n    });\n  }, [updateSignal]);\n  const markSignalAsUnread = useCallback(signalId => {\n    updateSignal(signalId, {\n      isRead: false\n    });\n  }, [updateSignal]);\n\n  // Function to get unread signals count\n  const getUnreadCount = useCallback(() => {\n    return signals.filter(signal => !signal.isRead).length;\n  }, [signals]);\n\n  // Function to export signals as CSV\n  const exportToCSV = useCallback(() => {\n    if (signals.length === 0) return '';\n    const headers = ['Symbol', 'Type', 'Strength', 'Confidence', 'Source', 'Generated At', 'Explanation'];\n    const csvRows = signals.map(signal => [signal.symbol, signal.signalType, signal.strength, signal.confidence, signal.source, new Date(signal.generatedAt).toLocaleString(), `\"${signal.explanation.replace(/\"/g, '\"\"')}\"` // Escape quotes in explanation\n    ]);\n    return [headers, ...csvRows].map(row => row.join(',')).join('\\n');\n  }, [signals]);\n  return {\n    // Core state\n    signals,\n    loading,\n    error,\n    // Core actions\n    refresh,\n    addSignal,\n    removeSignal,\n    clearSignals,\n    updateSignal,\n    // Filtering functions\n    filterByType,\n    filterByStrength,\n    filterBySymbol,\n    getActiveSignals,\n    getExpiredSignals,\n    // Utility functions\n    getStats,\n    markSignalAsRead,\n    markSignalAsUnread,\n    getUnreadCount,\n    exportToCSV\n  };\n};\n_s(useSignals, \"9DhIOkJcHFnodyBYrHiV0YRpOIc=\");\nexport default useSignals;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","api","useSignals","filters","_s","signals","setSignals","loading","setLoading","error","setError","abortControllerRef","generateMockSignals","limit","symbols","signalTypes","sources","Array","from","length","_","i","_id","Date","now","symbol","Math","floor","random","signalType","strength","confidence","source","generatedAt","explanation","expiration","isMock","fetchSignals","currentFilters","abortSignal","data","getSignals","signalsData","isArray","pagination","aborted","err","name","console","log","message","includes","mockSignals","current","abort","AbortController","signal","refresh","addSignal","signalData","newSignal","isManual","prev","removeSignal","signalId","filter","clearSignals","filterByType","filterByStrength","minStrength","filterBySymbol","toUpperCase","getActiveSignals","getExpiredSignals","getStats","total","buySignals","s","sellSignals","neutralSignals","averageStrength","reduce","sum","averageConfidence","strongSignals","activeSignals","expiredSignals","parseFloat","toFixed","buyPercentage","sellPercentage","updateSignal","updates","map","updatedAt","markSignalAsRead","isRead","markSignalAsUnread","getUnreadCount","exportToCSV","headers","csvRows","toLocaleString","replace","row","join"],"sources":["C:/Users/Ayush Goel/OneDrive/Desktop/DEPLOYED/STOCKMARKET/frontend/src/hooks/useSignals.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\r\nimport { api } from '../services/api';\r\n\r\nexport const useSignals = (filters = {}) => {\r\n  const [signals, setSignals] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const abortControllerRef = useRef(null);\r\n\r\n  // Memoize the mock data generator to prevent recreation on every render\r\n  const generateMockSignals = useCallback((limit = 10) => {\r\n    const symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META'];\r\n    const signalTypes = ['BUY', 'SELL', 'NEUTRAL'];\r\n    const sources = ['technical', 'news', 'market', 'pattern'];\r\n    \r\n    return Array.from({ length: limit }, (_, i) => ({\r\n      _id: `mock_signal_${Date.now()}_${i}`,\r\n      symbol: symbols[Math.floor(Math.random() * symbols.length)],\r\n      signalType: signalTypes[Math.floor(Math.random() * signalTypes.length)],\r\n      strength: Math.random() * 0.5 + 0.5,\r\n      confidence: Math.random() * 0.3 + 0.7,\r\n      source: sources[Math.floor(Math.random() * sources.length)],\r\n      generatedAt: new Date(),\r\n      explanation: 'Mock data - server connection issue',\r\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\r\n      isMock: true // Flag to identify mock data\r\n    }));\r\n  }, []);\r\n\r\n  // Memoize the fetch function to prevent unnecessary recreations\r\n  const fetchSignals = useCallback(async (currentFilters, abortSignal) => {\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n      \r\n      const data = await api.getSignals(currentFilters);\r\n      \r\n      // Handle different response formats\r\n      let signalsData = [];\r\n      if (Array.isArray(data)) {\r\n        signalsData = data;\r\n      } else if (data && Array.isArray(data.signals)) {\r\n        signalsData = data.signals;\r\n      } else if (data && data.pagination && Array.isArray(data.pagination.signals)) {\r\n        signalsData = data.pagination.signals;\r\n      }\r\n      \r\n      if (!abortSignal?.aborted) {\r\n        setSignals(signalsData);\r\n      }\r\n    } catch (err) {\r\n      if (err.name === 'AbortError') {\r\n        console.log('Signal fetch request was aborted');\r\n        return;\r\n      }\r\n      \r\n      console.error('Error fetching signals:', err);\r\n      \r\n      if (!abortSignal?.aborted) {\r\n        setError(err.message);\r\n        \r\n        // Fallback to mock data for specific error types\r\n        if (err.message.includes('Network error') || \r\n            err.message.includes('Failed to fetch') || \r\n            err.message.includes('Cannot connect to server')) {\r\n          const mockSignals = generateMockSignals(currentFilters.limit || 10);\r\n          setSignals(mockSignals);\r\n          setError('Using mock data (server unavailable)');\r\n        } else {\r\n          setSignals([]);\r\n        }\r\n      }\r\n    } finally {\r\n      if (!abortSignal?.aborted) {\r\n        setLoading(false);\r\n      }\r\n    }\r\n  }, [generateMockSignals]);\r\n\r\n  useEffect(() => {\r\n    // Cancel previous request if it exists\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n    }\r\n    \r\n    abortControllerRef.current = new AbortController();\r\n    const abortSignal = abortControllerRef.current.signal;\r\n\r\n    fetchSignals(filters, abortSignal);\r\n\r\n    // Cleanup function to abort request if component unmounts or filters change\r\n    return () => {\r\n      if (abortControllerRef.current && !abortSignal.aborted) {\r\n        abortControllerRef.current.abort();\r\n      }\r\n    };\r\n  }, [filters, fetchSignals]);\r\n\r\n  const refresh = useCallback(async () => {\r\n    // Cancel any ongoing request\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n    }\r\n    \r\n    abortControllerRef.current = new AbortController();\r\n    const abortSignal = abortControllerRef.current.signal;\r\n\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n      \r\n      const data = await api.getSignals(filters);\r\n      \r\n      // Handle different response formats\r\n      let signalsData = [];\r\n      if (Array.isArray(data)) {\r\n        signalsData = data;\r\n      } else if (data && Array.isArray(data.signals)) {\r\n        signalsData = data.signals;\r\n      }\r\n      \r\n      if (!abortSignal.aborted) {\r\n        setSignals(signalsData);\r\n      }\r\n    } catch (err) {\r\n      if (err.name === 'AbortError') {\r\n        console.log('Refresh request was aborted');\r\n        return;\r\n      }\r\n      \r\n      console.error('Error refreshing signals:', err);\r\n      if (!abortSignal.aborted) {\r\n        setError(err.message);\r\n        \r\n        // Fallback to mock data\r\n        if (err.message.includes('Network error') || \r\n            err.message.includes('Failed to fetch')) {\r\n          const mockSignals = generateMockSignals(filters.limit || 10);\r\n          setSignals(mockSignals);\r\n          setError('Using mock data (server unavailable)');\r\n        }\r\n      }\r\n    } finally {\r\n      if (!abortSignal.aborted) {\r\n        setLoading(false);\r\n      }\r\n    }\r\n  }, [filters, generateMockSignals]);\r\n\r\n  // Function to manually add a signal (useful for testing)\r\n  const addSignal = useCallback((signalData) => {\r\n    const newSignal = {\r\n      _id: `manual_${Date.now()}`,\r\n      symbol: signalData.symbol,\r\n      signalType: signalData.signalType || 'NEUTRAL',\r\n      strength: signalData.strength || 0.5,\r\n      confidence: signalData.confidence || 0.7,\r\n      source: signalData.source || 'manual',\r\n      generatedAt: new Date(),\r\n      explanation: signalData.explanation || 'Manually added signal',\r\n      expiration: new Date(Date.now() + 2 * 60 * 60 * 1000),\r\n      isManual: true\r\n    };\r\n    \r\n    setSignals(prev => [newSignal, ...prev]);\r\n  }, []);\r\n\r\n  // Function to remove a signal by ID\r\n  const removeSignal = useCallback((signalId) => {\r\n    setSignals(prev => prev.filter(signal => signal._id !== signalId));\r\n  }, []);\r\n\r\n  // Function to clear all signals\r\n  const clearSignals = useCallback(() => {\r\n    setSignals([]);\r\n  }, []);\r\n\r\n  // Function to filter signals by type\r\n  const filterByType = useCallback((signalType) => {\r\n    return signals.filter(signal => signal.signalType === signalType);\r\n  }, [signals]);\r\n\r\n  // Function to filter signals by strength threshold\r\n  const filterByStrength = useCallback((minStrength = 0.7) => {\r\n    return signals.filter(signal => signal.strength >= minStrength);\r\n  }, [signals]);\r\n\r\n  // Function to filter signals by symbol\r\n  const filterBySymbol = useCallback((symbol) => {\r\n    return signals.filter(signal => signal.symbol === symbol.toUpperCase());\r\n  }, [signals]);\r\n\r\n  // Function to get active signals (not expired)\r\n  const getActiveSignals = useCallback(() => {\r\n    const now = new Date();\r\n    return signals.filter(signal => \r\n      !signal.expiration || new Date(signal.expiration) > now\r\n    );\r\n  }, [signals]);\r\n\r\n  // Function to get expired signals\r\n  const getExpiredSignals = useCallback(() => {\r\n    const now = new Date();\r\n    return signals.filter(signal => \r\n      signal.expiration && new Date(signal.expiration) <= now\r\n    );\r\n  }, [signals]);\r\n\r\n  // Function to get statistics\r\n  const getStats = useCallback(() => {\r\n    const total = signals.length;\r\n    const buySignals = signals.filter(s => s.signalType === 'BUY').length;\r\n    const sellSignals = signals.filter(s => s.signalType === 'SELL').length;\r\n    const neutralSignals = signals.filter(s => s.signalType === 'NEUTRAL').length;\r\n    const averageStrength = signals.reduce((sum, s) => sum + s.strength, 0) / total || 0;\r\n    const averageConfidence = signals.reduce((sum, s) => sum + s.confidence, 0) / total || 0;\r\n    const strongSignals = signals.filter(s => s.strength > 0.7).length;\r\n    const activeSignals = getActiveSignals().length;\r\n    const expiredSignals = getExpiredSignals().length;\r\n\r\n    return {\r\n      total,\r\n      buySignals,\r\n      sellSignals,\r\n      neutralSignals,\r\n      averageStrength: parseFloat(averageStrength.toFixed(2)),\r\n      averageConfidence: parseFloat(averageConfidence.toFixed(2)),\r\n      strongSignals,\r\n      activeSignals,\r\n      expiredSignals,\r\n      buyPercentage: total > 0 ? parseFloat((buySignals / total * 100).toFixed(1)) : 0,\r\n      sellPercentage: total > 0 ? parseFloat((sellSignals / total * 100).toFixed(1)) : 0\r\n    };\r\n  }, [signals, getActiveSignals, getExpiredSignals]);\r\n\r\n  // Function to update a signal\r\n  const updateSignal = useCallback((signalId, updates) => {\r\n    setSignals(prev => prev.map(signal => \r\n      signal._id === signalId ? { ...signal, ...updates, updatedAt: new Date() } : signal\r\n    ));\r\n  }, []);\r\n\r\n  // Function to mark signal as read/unread\r\n  const markSignalAsRead = useCallback((signalId) => {\r\n    updateSignal(signalId, { isRead: true });\r\n  }, [updateSignal]);\r\n\r\n  const markSignalAsUnread = useCallback((signalId) => {\r\n    updateSignal(signalId, { isRead: false });\r\n  }, [updateSignal]);\r\n\r\n  // Function to get unread signals count\r\n  const getUnreadCount = useCallback(() => {\r\n    return signals.filter(signal => !signal.isRead).length;\r\n  }, [signals]);\r\n\r\n  // Function to export signals as CSV\r\n  const exportToCSV = useCallback(() => {\r\n    if (signals.length === 0) return '';\r\n    \r\n    const headers = ['Symbol', 'Type', 'Strength', 'Confidence', 'Source', 'Generated At', 'Explanation'];\r\n    const csvRows = signals.map(signal => [\r\n      signal.symbol,\r\n      signal.signalType,\r\n      signal.strength,\r\n      signal.confidence,\r\n      signal.source,\r\n      new Date(signal.generatedAt).toLocaleString(),\r\n      `\"${signal.explanation.replace(/\"/g, '\"\"')}\"` // Escape quotes in explanation\r\n    ]);\r\n    \r\n    return [headers, ...csvRows].map(row => row.join(',')).join('\\n');\r\n  }, [signals]);\r\n\r\n  return { \r\n    // Core state\r\n    signals, \r\n    loading, \r\n    error, \r\n    \r\n    // Core actions\r\n    refresh,\r\n    addSignal,\r\n    removeSignal,\r\n    clearSignals,\r\n    updateSignal,\r\n    \r\n    // Filtering functions\r\n    filterByType,\r\n    filterByStrength,\r\n    filterBySymbol,\r\n    getActiveSignals,\r\n    getExpiredSignals,\r\n    \r\n    // Utility functions\r\n    getStats,\r\n    markSignalAsRead,\r\n    markSignalAsUnread,\r\n    getUnreadCount,\r\n    exportToCSV\r\n  };\r\n};\r\n\r\nexport default useSignals;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}