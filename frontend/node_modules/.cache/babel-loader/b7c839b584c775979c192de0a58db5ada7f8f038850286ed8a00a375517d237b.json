{"ast":null,"code":"const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\nclass ApiService {\n  constructor() {\n    this.baseURL = API_BASE_URL;\n    this.pendingRequests = new Map();\n    this.requestQueue = [];\n    this.maxConcurrentRequests = 6; // Limit concurrent requests\n    this.activeRequests = 0;\n  }\n  async request(endpoint, options = {}) {\n    const requestId = `${endpoint}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    // Check if this is a duplicate request\n    if (this.pendingRequests.has(endpoint)) {\n      console.warn(`Duplicate request prevented: ${endpoint}`);\n      return this.pendingRequests.get(endpoint);\n    }\n\n    // Wait if too many concurrent requests\n    if (this.activeRequests >= this.maxConcurrentRequests) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return this.request(endpoint, options); // Retry\n    }\n    const url = `${this.baseURL}${endpoint}`;\n    const token = localStorage.getItem('token');\n    const headers = {\n      'Content-Type': 'application/json',\n      ...options.headers\n    };\n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout\n\n    const config = {\n      ...options,\n      headers,\n      signal: controller.signal\n    };\n    this.activeRequests++;\n    this.pendingRequests.set(endpoint, new Promise(() => {})); // Placeholder\n\n    try {\n      const response = await fetch(url, config);\n      clearTimeout(timeoutId);\n\n      // Handle HTTP errors\n      if (!response.ok) {\n        if (response.status === 401) {\n          localStorage.removeItem('token');\n          window.location.reload();\n          throw new Error('Authentication failed. Please login again.');\n        }\n        let errorMessage = `HTTP error! status: ${response.status}`;\n        try {\n          const errorData = await response.json();\n          errorMessage = errorData.message || errorData.error || errorMessage;\n        } catch (e) {\n          errorMessage = response.statusText || errorMessage;\n        }\n        throw new Error(errorMessage);\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error('API request failed:', error);\n      if (error.name === 'AbortError') {\n        throw new Error('Request timeout - server is not responding');\n      } else if (error.name === 'TypeError' && error.message === 'Failed to fetch') {\n        // Handle resource errors with retry logic\n        if (endpoint.includes('/api/signals')) {\n          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second\n          return this.request(endpoint, options); // Retry once\n        }\n        throw new Error('Network error - please check your connection');\n      }\n      throw error;\n    } finally {\n      this.activeRequests--;\n      this.pendingRequests.delete(endpoint);\n      clearTimeout(timeoutId);\n    }\n  }\n\n  // Signals endpoints with optimized caching\n  async getSignals(params = {}) {\n    const cacheKey = `signals-${JSON.stringify(params)}`;\n    const cache = sessionStorage.getItem(cacheKey);\n\n    // Return cached data if available and not too old\n    if (cache) {\n      try {\n        const {\n          data,\n          timestamp\n        } = JSON.parse(cache);\n        if (Date.now() - timestamp < 30000) {\n          // 30 second cache\n          return data;\n        }\n      } catch (e) {\n        // Cache is invalid, continue with fresh request\n      }\n    }\n    try {\n      const queryString = new URLSearchParams(params).toString();\n      const response = await this.request(`/api/signals?${queryString}`);\n      let signals = [];\n      if (Array.isArray(response)) {\n        signals = response;\n      } else if (response && Array.isArray(response.signals)) {\n        signals = response.signals;\n      } else if (response && response.pagination) {\n        signals = response.signals || [];\n      }\n\n      // Cache the response\n      sessionStorage.setItem(cacheKey, JSON.stringify({\n        data: signals,\n        timestamp: Date.now()\n      }));\n      return signals;\n    } catch (error) {\n      console.error('Failed to get signals:', error);\n\n      // Try to return cached data as fallback\n      if (cache) {\n        try {\n          const {\n            data\n          } = JSON.parse(cache);\n          return data;\n        } catch (e) {\n          // Cache is invalid\n        }\n      }\n      return []; // Return empty array on error\n    }\n  }\n\n  // ... keep the other methods the same as before, but add similar caching for frequently used endpoints ...\n\n  async getMarketData(symbol, period = '1d') {\n    const cacheKey = `market-data-${symbol}-${period}`;\n    const cache = sessionStorage.getItem(cacheKey);\n    if (cache) {\n      try {\n        const {\n          data,\n          timestamp\n        } = JSON.parse(cache);\n        if (Date.now() - timestamp < 60000) {\n          // 1 minute cache for market data\n          return data;\n        }\n      } catch (e) {\n        // Cache is invalid\n      }\n    }\n    try {\n      const response = await this.request(`/api/market-data/${symbol}?period=${period}`);\n      const data = Array.isArray(response) ? response : [];\n      sessionStorage.setItem(cacheKey, JSON.stringify({\n        data,\n        timestamp: Date.now()\n      }));\n      return data;\n    } catch (error) {\n      console.error('Failed to get market data:', error);\n      if (cache) {\n        try {\n          const {\n            data\n          } = JSON.parse(cache);\n          return data;\n        } catch (e) {\n          // Cache is invalid\n        }\n      }\n      return [];\n    }\n  }\n}\nexport const api = new ApiService();\nexport default api;","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","ApiService","constructor","baseURL","pendingRequests","Map","requestQueue","maxConcurrentRequests","activeRequests","request","endpoint","options","requestId","Date","now","Math","random","toString","substr","has","console","warn","get","Promise","resolve","setTimeout","url","token","localStorage","getItem","headers","controller","AbortController","timeoutId","abort","config","signal","set","response","fetch","clearTimeout","ok","status","removeItem","window","location","reload","Error","errorMessage","errorData","json","message","error","e","statusText","data","name","includes","delete","getSignals","params","cacheKey","JSON","stringify","cache","sessionStorage","timestamp","parse","queryString","URLSearchParams","signals","Array","isArray","pagination","setItem","getMarketData","symbol","period","api"],"sources":["C:/Users/Ayush Goel/OneDrive/Desktop/DEPLOYED/STOCKMARKET/frontend/src/services/api.js"],"sourcesContent":["const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\r\n\r\nclass ApiService {\r\n  constructor() {\r\n    this.baseURL = API_BASE_URL;\r\n    this.pendingRequests = new Map();\r\n    this.requestQueue = [];\r\n    this.maxConcurrentRequests = 6; // Limit concurrent requests\r\n    this.activeRequests = 0;\r\n  }\r\n\r\n  async request(endpoint, options = {}) {\r\n    const requestId = `${endpoint}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    \r\n    // Check if this is a duplicate request\r\n    if (this.pendingRequests.has(endpoint)) {\r\n      console.warn(`Duplicate request prevented: ${endpoint}`);\r\n      return this.pendingRequests.get(endpoint);\r\n    }\r\n\r\n    // Wait if too many concurrent requests\r\n    if (this.activeRequests >= this.maxConcurrentRequests) {\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n      return this.request(endpoint, options); // Retry\r\n    }\r\n\r\n    const url = `${this.baseURL}${endpoint}`;\r\n    const token = localStorage.getItem('token');\r\n    \r\n    const headers = {\r\n      'Content-Type': 'application/json',\r\n      ...options.headers\r\n    };\r\n    \r\n    if (token) {\r\n      headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    \r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout\r\n    \r\n    const config = {\r\n      ...options,\r\n      headers,\r\n      signal: controller.signal\r\n    };\r\n    \r\n    this.activeRequests++;\r\n    this.pendingRequests.set(endpoint, new Promise(() => {})); // Placeholder\r\n\r\n    try {\r\n      const response = await fetch(url, config);\r\n      clearTimeout(timeoutId);\r\n      \r\n      // Handle HTTP errors\r\n      if (!response.ok) {\r\n        if (response.status === 401) {\r\n          localStorage.removeItem('token');\r\n          window.location.reload();\r\n          throw new Error('Authentication failed. Please login again.');\r\n        }\r\n        \r\n        let errorMessage = `HTTP error! status: ${response.status}`;\r\n        try {\r\n          const errorData = await response.json();\r\n          errorMessage = errorData.message || errorData.error || errorMessage;\r\n        } catch (e) {\r\n          errorMessage = response.statusText || errorMessage;\r\n        }\r\n        \r\n        throw new Error(errorMessage);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      return data;\r\n      \r\n    } catch (error) {\r\n      console.error('API request failed:', error);\r\n      \r\n      if (error.name === 'AbortError') {\r\n        throw new Error('Request timeout - server is not responding');\r\n      } else if (error.name === 'TypeError' && error.message === 'Failed to fetch') {\r\n        // Handle resource errors with retry logic\r\n        if (endpoint.includes('/api/signals')) {\r\n          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second\r\n          return this.request(endpoint, options); // Retry once\r\n        }\r\n        throw new Error('Network error - please check your connection');\r\n      }\r\n      \r\n      throw error;\r\n    } finally {\r\n      this.activeRequests--;\r\n      this.pendingRequests.delete(endpoint);\r\n      clearTimeout(timeoutId);\r\n    }\r\n  }\r\n\r\n  // Signals endpoints with optimized caching\r\n  async getSignals(params = {}) {\r\n    const cacheKey = `signals-${JSON.stringify(params)}`;\r\n    const cache = sessionStorage.getItem(cacheKey);\r\n    \r\n    // Return cached data if available and not too old\r\n    if (cache) {\r\n      try {\r\n        const { data, timestamp } = JSON.parse(cache);\r\n        if (Date.now() - timestamp < 30000) { // 30 second cache\r\n          return data;\r\n        }\r\n      } catch (e) {\r\n        // Cache is invalid, continue with fresh request\r\n      }\r\n    }\r\n    \r\n    try {\r\n      const queryString = new URLSearchParams(params).toString();\r\n      const response = await this.request(`/api/signals?${queryString}`);\r\n      \r\n      let signals = [];\r\n      if (Array.isArray(response)) {\r\n        signals = response;\r\n      } else if (response && Array.isArray(response.signals)) {\r\n        signals = response.signals;\r\n      } else if (response && response.pagination) {\r\n        signals = response.signals || [];\r\n      }\r\n      \r\n      // Cache the response\r\n      sessionStorage.setItem(cacheKey, JSON.stringify({\r\n        data: signals,\r\n        timestamp: Date.now()\r\n      }));\r\n      \r\n      return signals;\r\n    } catch (error) {\r\n      console.error('Failed to get signals:', error);\r\n      \r\n      // Try to return cached data as fallback\r\n      if (cache) {\r\n        try {\r\n          const { data } = JSON.parse(cache);\r\n          return data;\r\n        } catch (e) {\r\n          // Cache is invalid\r\n        }\r\n      }\r\n      \r\n      return []; // Return empty array on error\r\n    }\r\n  }\r\n\r\n  // ... keep the other methods the same as before, but add similar caching for frequently used endpoints ...\r\n\r\n  async getMarketData(symbol, period = '1d') {\r\n    const cacheKey = `market-data-${symbol}-${period}`;\r\n    const cache = sessionStorage.getItem(cacheKey);\r\n    \r\n    if (cache) {\r\n      try {\r\n        const { data, timestamp } = JSON.parse(cache);\r\n        if (Date.now() - timestamp < 60000) { // 1 minute cache for market data\r\n          return data;\r\n        }\r\n      } catch (e) {\r\n        // Cache is invalid\r\n      }\r\n    }\r\n    \r\n    try {\r\n      const response = await this.request(`/api/market-data/${symbol}?period=${period}`);\r\n      const data = Array.isArray(response) ? response : [];\r\n      \r\n      sessionStorage.setItem(cacheKey, JSON.stringify({\r\n        data,\r\n        timestamp: Date.now()\r\n      }));\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      console.error('Failed to get market data:', error);\r\n      \r\n      if (cache) {\r\n        try {\r\n          const { data } = JSON.parse(cache);\r\n          return data;\r\n        } catch (e) {\r\n          // Cache is invalid\r\n        }\r\n      }\r\n      \r\n      return [];\r\n    }\r\n  }\r\n}\r\n\r\nexport const api = new ApiService();\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}